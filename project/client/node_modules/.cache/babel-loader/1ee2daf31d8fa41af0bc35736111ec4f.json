{"ast":null,"code":"import { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\nimport processFinishedRequest from \"./processFinishedRequest\";\n\nconst abortNonUploadingItem = (queue, item, next) => {\n  logger.debugLog(`uploader.queue: aborting ${item.state} item  - `, item); //manually finish request for item that hasnt reached the sender yet\n\n  processFinishedRequest(queue, [{\n    id: item.id,\n    info: {\n      status: 0,\n      state: FILE_STATES.ABORTED,\n      response: \"aborted\"\n    }\n  }], next);\n  return true;\n};\n\nconst ITEM_STATE_ABORTS = {\n  [FILE_STATES.UPLOADING]: (queue, item) => {\n    logger.debugLog(`uploader.queue: aborting uploading item  - `, item);\n    return queue.getState().aborts[item.id]();\n  },\n  [FILE_STATES.ADDED]: abortNonUploadingItem,\n  [FILE_STATES.PENDING]: abortNonUploadingItem\n};\n\nconst callAbortOnItem = (queue, id, next) => {\n  const state = queue.getState(),\n        item = state.items[id],\n        itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\n\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\n  //$FlowIssue[prop-missing]\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\n};\n\nconst abortAll = (queue, next) => {\n  const items = queue.getState().items;\n  Object.keys(items).forEach(id => callAbortOnItem(queue, id, next));\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\n};\n\nconst abortItem = (queue, id, next) => callAbortOnItem(queue, id, next);\n\nconst abortBatch = (queue, id, next) => {\n  const state = queue.getState(),\n        batchData = state.batches[id],\n        batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\n\n  if (batch && !getIsBatchFinalized(batch)) {\n    queue.updateState(state => {\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\n    });\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\n    batch.items.forEach(bi => callAbortOnItem(queue, bi.id, next));\n  }\n};\n\nexport { abortAll, abortItem, abortBatch };","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/uploader/lib/esm/queue/abort.js"],"names":["BATCH_STATES","FILE_STATES","logger","UPLOADER_EVENTS","triggerUploaderBatchEvent","getBatchFromState","getIsBatchFinalized","processFinishedRequest","abortNonUploadingItem","queue","item","next","debugLog","state","id","info","status","ABORTED","response","ITEM_STATE_ABORTS","UPLOADING","getState","aborts","ADDED","PENDING","callAbortOnItem","items","itemState","abortAll","Object","keys","forEach","trigger","ALL_ABORT","abortItem","abortBatch","batchData","batches","batch","updateState","BATCH_ABORT","bi"],"mappings":"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","sourcesContent":["import { BATCH_STATES, FILE_STATES, logger } from \"@rpldy/shared\";\r\nimport { UPLOADER_EVENTS } from \"../consts\";\r\nimport { triggerUploaderBatchEvent, getBatchFromState, getIsBatchFinalized } from \"./batchHelpers\";\r\nimport processFinishedRequest from \"./processFinishedRequest\";\r\n\r\nconst abortNonUploadingItem = (queue, item, next) => {\r\n  logger.debugLog(`uploader.queue: aborting ${item.state} item  - `, item); //manually finish request for item that hasnt reached the sender yet\r\n\r\n  processFinishedRequest(queue, [{\r\n    id: item.id,\r\n    info: {\r\n      status: 0,\r\n      state: FILE_STATES.ABORTED,\r\n      response: \"aborted\"\r\n    }\r\n  }], next);\r\n  return true;\r\n};\r\n\r\nconst ITEM_STATE_ABORTS = {\r\n  [FILE_STATES.UPLOADING]: (queue, item) => {\r\n    logger.debugLog(`uploader.queue: aborting uploading item  - `, item);\r\n    return queue.getState().aborts[item.id]();\r\n  },\r\n  [FILE_STATES.ADDED]: abortNonUploadingItem,\r\n  [FILE_STATES.PENDING]: abortNonUploadingItem\r\n};\r\n\r\nconst callAbortOnItem = (queue, id, next) => {\r\n  const state = queue.getState(),\r\n        item = state.items[id],\r\n        itemState = item === null || item === void 0 ? void 0 : item.state; //$FlowIssue[prop-missing]\r\n\r\n  return ITEM_STATE_ABORTS[itemState] ? //$FlowExpectedError[extra-arg]\r\n  //$FlowIssue[prop-missing]\r\n  ITEM_STATE_ABORTS[itemState](queue, item, next) : false;\r\n};\r\n\r\nconst abortAll = (queue, next) => {\r\n  const items = queue.getState().items;\r\n  Object.keys(items).forEach(id => callAbortOnItem(queue, id, next));\r\n  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);\r\n};\r\n\r\nconst abortItem = (queue, id, next) => callAbortOnItem(queue, id, next);\r\n\r\nconst abortBatch = (queue, id, next) => {\r\n  const state = queue.getState(),\r\n        batchData = state.batches[id],\r\n        batch = batchData === null || batchData === void 0 ? void 0 : batchData.batch;\r\n\r\n  if (batch && !getIsBatchFinalized(batch)) {\r\n    queue.updateState(state => {\r\n      getBatchFromState(state, id).state = BATCH_STATES.ABORTED;\r\n    });\r\n    triggerUploaderBatchEvent(queue, id, UPLOADER_EVENTS.BATCH_ABORT);\r\n    batch.items.forEach(bi => callAbortOnItem(queue, bi.id, next));\r\n  }\r\n};\r\n\r\nexport { abortAll, abortItem, abortBatch };"]},"metadata":{},"sourceType":"module"}