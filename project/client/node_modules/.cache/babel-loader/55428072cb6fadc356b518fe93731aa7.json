{"ast":null,"code":"import { FILE_STATES } from \"./consts\";\nconst BISYM = Symbol.for(\"__rpldy-bi__\");\nlet iCounter = 0;\n\nconst getBatchItemWithUrl = (batchItem, url) => {\n  batchItem.url = url;\n  return batchItem;\n};\n\nconst getBatchItemWithFile = (batchItem, file) => {\n  batchItem.file = file;\n  return batchItem;\n};\n\nconst isLikeFile = f => f && (f instanceof File || f instanceof Blob || typeof f === \"object\" && f.name && f.type);\n\nexport default ((f, batchId, isPending = false) => {\n  iCounter += f.id && f.batchId ? 0 : 1; //keep existing id for recycled items\n\n  const id = f.id && f.batchId ? f.id : `${batchId}.item-${iCounter}`,\n        state = isPending ? FILE_STATES.PENDING : FILE_STATES.ADDED;\n  let batchItem = {\n    id,\n    batchId,\n    state,\n    uploadStatus: 0,\n    completed: 0,\n    loaded: 0,\n    aborted: false,\n    recycled: false,\n    previousBatch: null\n  };\n  Object.defineProperty(batchItem, BISYM, {\n    value: true,\n    //need writable to be able to keep prop when unwrapped from simple-state\n    writable: true\n  });\n\n  if (typeof f === \"object\" && f[BISYM] === true) {\n    //recycling existing batch item\n    batchItem.recycled = true;\n    batchItem.previousBatch = f.batchId;\n    f = f.file || f.url;\n  }\n\n  if (typeof f === \"string\") {\n    batchItem = getBatchItemWithUrl(batchItem, f);\n  } else if (isLikeFile(f)) {\n    batchItem = getBatchItemWithFile(batchItem, f);\n  } else {\n    throw new Error(`Unknown type of file added: ${typeof f}`);\n  }\n\n  return batchItem;\n});","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/shared/lib/esm/batchItem.js"],"names":["FILE_STATES","BISYM","Symbol","for","iCounter","getBatchItemWithUrl","batchItem","url","getBatchItemWithFile","file","isLikeFile","f","File","Blob","name","type","batchId","isPending","id","state","PENDING","ADDED","uploadStatus","completed","loaded","aborted","recycled","previousBatch","Object","defineProperty","value","writable","Error"],"mappings":"AAAA,SAASA,WAAT,QAA4B,UAA5B;AACA,MAAMC,KAAK,GAAGC,MAAM,CAACC,GAAP,CAAW,cAAX,CAAd;AACA,IAAIC,QAAQ,GAAG,CAAf;;AAEA,MAAMC,mBAAmB,GAAG,CAACC,SAAD,EAAYC,GAAZ,KAAoB;AAC9CD,EAAAA,SAAS,CAACC,GAAV,GAAgBA,GAAhB;AACA,SAAOD,SAAP;AACD,CAHD;;AAKA,MAAME,oBAAoB,GAAG,CAACF,SAAD,EAAYG,IAAZ,KAAqB;AAChDH,EAAAA,SAAS,CAACG,IAAV,GAAiBA,IAAjB;AACA,SAAOH,SAAP;AACD,CAHD;;AAKA,MAAMI,UAAU,GAAGC,CAAC,IAAIA,CAAC,KAAKA,CAAC,YAAYC,IAAb,IAAqBD,CAAC,YAAYE,IAAlC,IAA0C,OAAOF,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAACG,IAA3B,IAAmCH,CAAC,CAACI,IAApF,CAAzB;;AAEA,gBAAgB,CAACJ,CAAD,EAAIK,OAAJ,EAAaC,SAAS,GAAG,KAAzB,KAAmC;AACjDb,EAAAA,QAAQ,IAAIO,CAAC,CAACO,EAAF,IAAQP,CAAC,CAACK,OAAV,GAAoB,CAApB,GAAwB,CAApC,CADiD,CACV;;AAEvC,QAAME,EAAE,GAAGP,CAAC,CAACO,EAAF,IAAQP,CAAC,CAACK,OAAV,GAAoBL,CAAC,CAACO,EAAtB,GAA4B,GAAEF,OAAQ,SAAQZ,QAAS,EAAlE;AAAA,QACMe,KAAK,GAAGF,SAAS,GAAGjB,WAAW,CAACoB,OAAf,GAAyBpB,WAAW,CAACqB,KAD5D;AAEA,MAAIf,SAAS,GAAG;AACdY,IAAAA,EADc;AAEdF,IAAAA,OAFc;AAGdG,IAAAA,KAHc;AAIdG,IAAAA,YAAY,EAAE,CAJA;AAKdC,IAAAA,SAAS,EAAE,CALG;AAMdC,IAAAA,MAAM,EAAE,CANM;AAOdC,IAAAA,OAAO,EAAE,KAPK;AAQdC,IAAAA,QAAQ,EAAE,KARI;AASdC,IAAAA,aAAa,EAAE;AATD,GAAhB;AAWAC,EAAAA,MAAM,CAACC,cAAP,CAAsBvB,SAAtB,EAAiCL,KAAjC,EAAwC;AACtC6B,IAAAA,KAAK,EAAE,IAD+B;AAEtC;AACAC,IAAAA,QAAQ,EAAE;AAH4B,GAAxC;;AAMA,MAAI,OAAOpB,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAACV,KAAD,CAAD,KAAa,IAA1C,EAAgD;AAC9C;AACAK,IAAAA,SAAS,CAACoB,QAAV,GAAqB,IAArB;AACApB,IAAAA,SAAS,CAACqB,aAAV,GAA0BhB,CAAC,CAACK,OAA5B;AACAL,IAAAA,CAAC,GAAGA,CAAC,CAACF,IAAF,IAAUE,CAAC,CAACJ,GAAhB;AACD;;AAED,MAAI,OAAOI,CAAP,KAAa,QAAjB,EAA2B;AACzBL,IAAAA,SAAS,GAAGD,mBAAmB,CAACC,SAAD,EAAYK,CAAZ,CAA/B;AACD,GAFD,MAEO,IAAID,UAAU,CAACC,CAAD,CAAd,EAAmB;AACxBL,IAAAA,SAAS,GAAGE,oBAAoB,CAACF,SAAD,EAAYK,CAAZ,CAAhC;AACD,GAFM,MAEA;AACL,UAAM,IAAIqB,KAAJ,CAAW,+BAA8B,OAAOrB,CAAE,EAAlD,CAAN;AACD;;AAED,SAAOL,SAAP;AACD,CAtCD","sourcesContent":["import { FILE_STATES } from \"./consts\";\r\nconst BISYM = Symbol.for(\"__rpldy-bi__\");\r\nlet iCounter = 0;\r\n\r\nconst getBatchItemWithUrl = (batchItem, url) => {\r\n  batchItem.url = url;\r\n  return batchItem;\r\n};\r\n\r\nconst getBatchItemWithFile = (batchItem, file) => {\r\n  batchItem.file = file;\r\n  return batchItem;\r\n};\r\n\r\nconst isLikeFile = f => f && (f instanceof File || f instanceof Blob || typeof f === \"object\" && f.name && f.type);\r\n\r\nexport default ((f, batchId, isPending = false) => {\r\n  iCounter += f.id && f.batchId ? 0 : 1; //keep existing id for recycled items\r\n\r\n  const id = f.id && f.batchId ? f.id : `${batchId}.item-${iCounter}`,\r\n        state = isPending ? FILE_STATES.PENDING : FILE_STATES.ADDED;\r\n  let batchItem = {\r\n    id,\r\n    batchId,\r\n    state,\r\n    uploadStatus: 0,\r\n    completed: 0,\r\n    loaded: 0,\r\n    aborted: false,\r\n    recycled: false,\r\n    previousBatch: null\r\n  };\r\n  Object.defineProperty(batchItem, BISYM, {\r\n    value: true,\r\n    //need writable to be able to keep prop when unwrapped from simple-state\r\n    writable: true\r\n  });\r\n\r\n  if (typeof f === \"object\" && f[BISYM] === true) {\r\n    //recycling existing batch item\r\n    batchItem.recycled = true;\r\n    batchItem.previousBatch = f.batchId;\r\n    f = f.file || f.url;\r\n  }\r\n\r\n  if (typeof f === \"string\") {\r\n    batchItem = getBatchItemWithUrl(batchItem, f);\r\n  } else if (isLikeFile(f)) {\r\n    batchItem = getBatchItemWithFile(batchItem, f);\r\n  } else {\r\n    throw new Error(`Unknown type of file added: ${typeof f}`);\r\n  }\r\n\r\n  return batchItem;\r\n});"]},"metadata":{},"sourceType":"module"}