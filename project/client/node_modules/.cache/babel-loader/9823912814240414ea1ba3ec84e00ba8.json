{"ast":null,"code":"import { logger, hasWindow, isFunction } from \"@rpldy/shared\";\nimport createState from \"@rpldy/simple-state\";\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\nimport processQueueNext from \"./processQueueNext\";\nimport * as abortMethods from \"./abort\";\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches } from \"./batchHelpers\";\n\nconst createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {\n  const {\n    state,\n    update\n  } = createState({\n    itemQueue: [],\n    currentBatch: null,\n    batches: {},\n    items: {},\n    activeIds: [],\n    aborts: {}\n  });\n\n  const getState = () => state;\n\n  const updateState = updater => {\n    update(updater);\n  };\n\n  const add = item => {\n    if (state.items[item.id] && !item.recycled) {\n      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);\n    }\n\n    if (item.recycled) {\n      detachRecycledFromPreviousBatch(queueState, item);\n    }\n\n    updateState(state => {\n      state.items[item.id] = item;\n      state.itemQueue.push(item.id);\n    });\n  };\n\n  const handleItemProgress = (item, completed, loaded) => {\n    if (state.items[item.id]) {\n      updateState(state => {\n        const stateItem = state.items[item.id];\n        stateItem.loaded = loaded;\n        stateItem.completed = completed;\n      }); //trigger item progress event for the outside\n\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\n    }\n  };\n\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, batch => {\n    var _state$batches$batch$;\n\n    const batchItems = (_state$batches$batch$ = state.batches[batch.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;\n\n    if (batchItems) {\n      const [completed, loaded] = batchItems.reduce((res, item) => {\n        res[0] += item.completed;\n        res[1] += item.loaded;\n        return res;\n      }, [0, 0]);\n      updateState(state => {\n        const stateBatch = state.batches[batch.id].batch; //average of completed percentage for batch items\n\n        stateBatch.completed = completed / batchItems.length; //sum of loaded bytes for batch items\n\n        stateBatch.loaded = loaded;\n      });\n      trigger(UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch.id].batch);\n    }\n  });\n  const queueState = {\n    uploaderId,\n    getOptions: () => options,\n    getCurrentActiveCount: () => state.activeIds.length,\n    getState,\n    updateState,\n    trigger,\n    runCancellable: (name, ...args) => {\n      if (!isFunction(cancellable)) {\n        //for flow :(\n        throw new Error(\"cancellable is of wrong type\");\n      }\n\n      return cancellable(name, ...args);\n    },\n    sender,\n    handleItemProgress\n  };\n\n  if (hasWindow() && logger.isDebugOn()) {\n    window[`__rpldy_${uploaderId}_queue_state`] = queueState;\n  }\n\n  return {\n    updateState,\n    getState: queueState.getState,\n    runCancellable: queueState.runCancellable,\n    uploadBatch: (batch, batchOptions) => {\n      if (batchOptions) {\n        updateState(state => {\n          state.batches[batch.id].batchOptions = batchOptions;\n        });\n      }\n\n      processQueueNext(queueState);\n    },\n    addBatch: (batch, batchOptions) => {\n      updateState(state => {\n        state.batches[batch.id] = {\n          batch,\n          batchOptions,\n          finishedCounter: 0\n        };\n      });\n      batch.items.forEach(add);\n      return getBatchFromState(state, batch.id);\n    },\n    abortItem: id => {\n      return abortMethods.abortItem(queueState, id, processQueueNext);\n    },\n    abortBatch: id => {\n      abortMethods.abortBatch(queueState, id, processQueueNext);\n    },\n    abortAll: () => {\n      abortMethods.abortAll(queueState, processQueueNext);\n    },\n    clearPendingBatches: () => {\n      removePendingBatches(queueState);\n    },\n    uploadPendingBatches: uploadOptions => {\n      preparePendingForUpload(queueState, uploadOptions);\n      processQueueNext(queueState);\n    }\n  };\n};\n\nexport default createUploaderQueue;","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/uploader/lib/esm/queue/uploaderQueue.js"],"names":["logger","hasWindow","isFunction","createState","SENDER_EVENTS","UPLOADER_EVENTS","processQueueNext","abortMethods","detachRecycledFromPreviousBatch","getBatchFromState","preparePendingForUpload","removePendingBatches","createUploaderQueue","options","trigger","cancellable","sender","uploaderId","state","update","itemQueue","currentBatch","batches","items","activeIds","aborts","getState","updateState","updater","add","item","id","recycled","Error","queueState","push","handleItemProgress","completed","loaded","stateItem","ITEM_PROGRESS","on","BATCH_PROGRESS","batch","_state$batches$batch$","batchItems","reduce","res","stateBatch","length","getOptions","getCurrentActiveCount","runCancellable","name","args","isDebugOn","window","uploadBatch","batchOptions","addBatch","finishedCounter","forEach","abortItem","abortBatch","abortAll","clearPendingBatches","uploadPendingBatches","uploadOptions"],"mappings":"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","sourcesContent":["import { logger, hasWindow, isFunction } from \"@rpldy/shared\";\r\nimport createState from \"@rpldy/simple-state\";\r\nimport { SENDER_EVENTS, UPLOADER_EVENTS } from \"../consts\";\r\nimport processQueueNext from \"./processQueueNext\";\r\nimport * as abortMethods from \"./abort\";\r\nimport { detachRecycledFromPreviousBatch, getBatchFromState, preparePendingForUpload, removePendingBatches } from \"./batchHelpers\";\r\n\r\nconst createUploaderQueue = (options, trigger, cancellable, sender, uploaderId) => {\r\n  const {\r\n    state,\r\n    update\r\n  } = createState({\r\n    itemQueue: [],\r\n    currentBatch: null,\r\n    batches: {},\r\n    items: {},\r\n    activeIds: [],\r\n    aborts: {}\r\n  });\r\n\r\n  const getState = () => state;\r\n\r\n  const updateState = updater => {\r\n    update(updater);\r\n  };\r\n\r\n  const add = item => {\r\n    if (state.items[item.id] && !item.recycled) {\r\n      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);\r\n    }\r\n\r\n    if (item.recycled) {\r\n      detachRecycledFromPreviousBatch(queueState, item);\r\n    }\r\n\r\n    updateState(state => {\r\n      state.items[item.id] = item;\r\n      state.itemQueue.push(item.id);\r\n    });\r\n  };\r\n\r\n  const handleItemProgress = (item, completed, loaded) => {\r\n    if (state.items[item.id]) {\r\n      updateState(state => {\r\n        const stateItem = state.items[item.id];\r\n        stateItem.loaded = loaded;\r\n        stateItem.completed = completed;\r\n      }); //trigger item progress event for the outside\r\n\r\n      trigger(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);\r\n    }\r\n  };\r\n\r\n  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);\r\n  sender.on(SENDER_EVENTS.BATCH_PROGRESS, batch => {\r\n    var _state$batches$batch$;\r\n\r\n    const batchItems = (_state$batches$batch$ = state.batches[batch.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;\r\n\r\n    if (batchItems) {\r\n      const [completed, loaded] = batchItems.reduce((res, item) => {\r\n        res[0] += item.completed;\r\n        res[1] += item.loaded;\r\n        return res;\r\n      }, [0, 0]);\r\n      updateState(state => {\r\n        const stateBatch = state.batches[batch.id].batch; //average of completed percentage for batch items\r\n\r\n        stateBatch.completed = completed / batchItems.length; //sum of loaded bytes for batch items\r\n\r\n        stateBatch.loaded = loaded;\r\n      });\r\n      trigger(UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch.id].batch);\r\n    }\r\n  });\r\n  const queueState = {\r\n    uploaderId,\r\n    getOptions: () => options,\r\n    getCurrentActiveCount: () => state.activeIds.length,\r\n    getState,\r\n    updateState,\r\n    trigger,\r\n    runCancellable: (name, ...args) => {\r\n      if (!isFunction(cancellable)) {\r\n        //for flow :(\r\n        throw new Error(\"cancellable is of wrong type\");\r\n      }\r\n\r\n      return cancellable(name, ...args);\r\n    },\r\n    sender,\r\n    handleItemProgress\r\n  };\r\n\r\n  if (hasWindow() && logger.isDebugOn()) {\r\n    window[`__rpldy_${uploaderId}_queue_state`] = queueState;\r\n  }\r\n\r\n  return {\r\n    updateState,\r\n    getState: queueState.getState,\r\n    runCancellable: queueState.runCancellable,\r\n    uploadBatch: (batch, batchOptions) => {\r\n      if (batchOptions) {\r\n        updateState(state => {\r\n          state.batches[batch.id].batchOptions = batchOptions;\r\n        });\r\n      }\r\n\r\n      processQueueNext(queueState);\r\n    },\r\n    addBatch: (batch, batchOptions) => {\r\n      updateState(state => {\r\n        state.batches[batch.id] = {\r\n          batch,\r\n          batchOptions,\r\n          finishedCounter: 0\r\n        };\r\n      });\r\n      batch.items.forEach(add);\r\n      return getBatchFromState(state, batch.id);\r\n    },\r\n    abortItem: id => {\r\n      return abortMethods.abortItem(queueState, id, processQueueNext);\r\n    },\r\n    abortBatch: id => {\r\n      abortMethods.abortBatch(queueState, id, processQueueNext);\r\n    },\r\n    abortAll: () => {\r\n      abortMethods.abortAll(queueState, processQueueNext);\r\n    },\r\n    clearPendingBatches: () => {\r\n      removePendingBatches(queueState);\r\n    },\r\n    uploadPendingBatches: uploadOptions => {\r\n      preparePendingForUpload(queueState, uploadOptions);\r\n      processQueueNext(queueState);\r\n    }\r\n  };\r\n};\r\n\r\nexport default createUploaderQueue;"]},"metadata":{},"sourceType":"module"}