{"ast":null,"code":"import isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\"; //TODO: implement STATS\n\nconst getLE = obj => obj ? obj[LESYM] : null;\n\nconst getValidLE = obj => {\n  const le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nconst isLE = obj => !!getLE(obj);\n\nconst addRegistration = (obj, name, cb, once = false) => {\n  validateFunction(cb, \"cb\");\n  const le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(`Cannot register for event ${name.toString()} that wasn't already defined (allowRegisterNonExistent = false)`);\n  }\n\n  const namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(r => r.cb === cb)) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name,\n      cb,\n      once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return () => unregister.call(obj, name, cb);\n};\n\nconst findRegistrations = (obj, name) => {\n  const registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nconst publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nconst getPublicMethods = () => Object.entries(publicMethods).reduce((res, [key, m]) => {\n  res[key] = {\n    value: m\n  };\n  return res;\n}, {}); //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nconst apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nconst createApi = target => Object.keys(apiMethods).reduce((res, name) => {\n  res[name] = apiMethods[name].bind(target);\n  return res;\n}, {\n  target,\n  ...apiMethods\n});\n\nconst cleanRegistryForName = (obj, name, force = false) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nconst removeRegItem = (obj, name, cb) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(reg => reg.cb !== cb);\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name, ...args) {\n  const regs = findRegistrations(this, name);\n  let results;\n\n  if (regs.length) {\n    var _args$;\n\n    let packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(r => {\n      let result;\n\n      if (r.once) {\n        removeRegItem(this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb(...packValue);\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb(...args);\n      }\n\n      return result;\n    }).filter(result => !isUndefined(result)).map(result => isPromise(result) ? result : Promise.resolve(result));\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  const le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    const index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(`Event '${name}' already defined`);\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    const index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  const le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nconst defineLifeData = (target, options, events = [], registry = {}, stats = {}) => {\n  Object.defineProperties(target, {\n    [LESYM]: {\n      value: Object.seal({\n        registry,\n        events,\n        options,\n        stats\n      })\n    },\n    ...getPublicMethods()\n  });\n};\n\nconst addLife = (target, events = [], options) => {\n  target = target || {};\n  options = { ...defaults,\n    ...options\n  };\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/project-good/project/client/node_modules/@rpldy/life-events/lib/esm/lifeEvents.js"],"names":["isPromise","defaults","validateFunction","isUndefined","LESYM","LE_PACK_SYM","getLE","obj","getValidLE","le","Error","isLE","addRegistration","name","cb","once","options","allowRegisterNonExistent","events","indexOf","toString","namedRegistry","registry","find","r","push","unregister","call","findRegistrations","slice","Object","values","flat","publicMethods","register","registerOnce","getEvents","getPublicMethods","entries","reduce","res","key","m","value","apiMethods","trigger","addEvent","removeEvent","hasEvent","hasEventRegistrations","assign","createApi","target","keys","bind","cleanRegistryForName","force","length","removeRegItem","filter","reg","args","regs","results","_args$","packValue","resolve","map","result","Promise","undefined","toObj","defineLifeData","stats","canAddEvents","index","canRemoveEvents","splice","defineProperties","seal","addLife"],"mappings":"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","sourcesContent":["import isPromise from \"is-promise\";\nimport defaults from \"./defaults\";\nimport { validateFunction, isUndefined } from \"./utils\";\nimport { LESYM, LE_PACK_SYM } from \"./consts\";\n\n//TODO: implement STATS\nconst getLE = obj => obj ? obj[LESYM] : null;\n\nconst getValidLE = obj => {\n  const le = getLE(obj);\n\n  if (!le) {\n    throw new Error(\"Didnt find LE internal object. Something very bad happened!\");\n  }\n\n  return le;\n};\n\nconst isLE = obj => !!getLE(obj);\n\nconst addRegistration = (obj, name, cb, once = false) => {\n  validateFunction(cb, \"cb\");\n  const le = getValidLE(obj);\n\n  if (!le.options.allowRegisterNonExistent && !~le.events.indexOf(name)) {\n    throw new Error(`Cannot register for event ${name.toString()} that wasn't already defined (allowRegisterNonExistent = false)`);\n  }\n\n  const namedRegistry = le.registry[name] || [];\n\n  if (!namedRegistry.find(r => r.cb === cb)) {\n    //only add same callback for a name once\n    namedRegistry.push({\n      name,\n      cb,\n      once\n    });\n    le.registry[name] = namedRegistry;\n  }\n\n  return () => unregister.call(obj, name, cb);\n};\n\nconst findRegistrations = (obj, name) => {\n  const registry = getValidLE(obj).registry;\n  return name ? registry[name] ? registry[name].slice() : [] : // $FlowFixMe - flow doesnt know about Array.prototype.flat yet...\n  Object.values(registry).flat();\n};\n\nconst publicMethods = {\n  \"on\": register,\n  \"once\": registerOnce,\n  \"off\": unregister,\n  \"getEvents\": getEvents\n};\n\nconst getPublicMethods = () => Object.entries(publicMethods).reduce((res, [key, m]) => {\n  res[key] = {\n    value: m\n  };\n  return res;\n}, {}); //using string keys here because can't rely on function names to stay after (babel/webpack) build\n\n\nconst apiMethods = {\n  \"trigger\": trigger,\n  \"addEvent\": addEvent,\n  \"removeEvent\": removeEvent,\n  \"hasEvent\": hasEvent,\n  \"hasEventRegistrations\": hasEventRegistrations,\n  \"assign\": assign\n};\n\nconst createApi = target => Object.keys(apiMethods).reduce((res, name) => {\n  res[name] = apiMethods[name].bind(target);\n  return res;\n}, {\n  target,\n  ...apiMethods\n});\n\nconst cleanRegistryForName = (obj, name, force = false) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name] && (force || !registry[name].length)) {\n    delete registry[name];\n  }\n};\n\nconst removeRegItem = (obj, name, cb) => {\n  const registry = getValidLE(obj).registry;\n\n  if (registry[name]) {\n    if (!cb) {\n      cleanRegistryForName(obj, name, true);\n    } else {\n      registry[name] = registry[name].filter(reg => reg.cb !== cb);\n      cleanRegistryForName(obj, name);\n    }\n  }\n};\n\nfunction register(name, cb) {\n  return addRegistration(this, name, cb);\n}\n\nfunction registerOnce(name, cb) {\n  return addRegistration(this, name, cb, true);\n}\n\nfunction unregister(name, cb) {\n  removeRegItem(this, name, cb);\n}\n\nfunction getEvents() {\n  return getValidLE(this).events.slice();\n}\n\nfunction trigger(name, ...args) {\n  const regs = findRegistrations(this, name);\n  let results;\n\n  if (regs.length) {\n    var _args$;\n\n    let packValue;\n\n    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {\n      //life-pack always returns array as params to spread\n      packValue = args[0].resolve();\n    }\n\n    results = regs.map(r => {\n      let result;\n\n      if (r.once) {\n        removeRegItem(this, name, r.cb);\n      }\n\n      if (packValue) {\n        result = r.cb(...packValue);\n      } else if (!args.length) {\n        result = r.cb();\n      } else if (args.length === 1) {\n        result = r.cb(args[0]);\n      } else if (args.length === 2) {\n        result = r.cb(args[0], args[1]);\n      } else if (args.length === 3) {\n        result = r.cb(args[0], args[1], args[2]);\n      } else {\n        result = r.cb(...args);\n      }\n\n      return result;\n    }).filter(result => !isUndefined(result)).map(result => isPromise(result) ? result : Promise.resolve(result));\n  }\n\n  return results && (results.length ? results : undefined);\n} //registry, events, stats become shared\n\n\nfunction assign(toObj) {\n  const le = getValidLE(this);\n  defineLifeData(toObj, le.options, le.events, le.registry, le.stats);\n  return createApi(toObj);\n}\n\nfunction addEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canAddEvents) {\n    const index = le.events.indexOf(name);\n\n    if (!~index) {\n      le.events.push(name);\n    } else {\n      throw new Error(`Event '${name}' already defined`);\n    }\n  } else {\n    throw new Error(\"Cannot add new events (canAddEvents = false)\");\n  }\n}\n\nfunction removeEvent(name) {\n  const le = getValidLE(this);\n\n  if (le.options.canRemoveEvents) {\n    const index = le.events.indexOf(name);\n    le.events.splice(index, 1);\n  } else {\n    throw new Error(\"Cannot remove events (canRemoveEvents = false)\");\n  }\n}\n\nfunction hasEvent(name) {\n  const le = getValidLE(this);\n  return !!~le.events.indexOf(name);\n}\n\nfunction hasEventRegistrations(name) {\n  return !!findRegistrations(this, name).length;\n} // function getStats(name?: any) {\n//\n// }\n\n\nconst defineLifeData = (target, options, events = [], registry = {}, stats = {}) => {\n  Object.defineProperties(target, {\n    [LESYM]: {\n      value: Object.seal({\n        registry,\n        events,\n        options,\n        stats\n      })\n    },\n    ...getPublicMethods()\n  });\n};\n\nconst addLife = (target, events = [], options) => {\n  target = target || {};\n  options = { ...defaults,\n    ...options\n  };\n\n  if (!isLE(target)) {\n    defineLifeData(target, options, events);\n  }\n\n  return createApi(target);\n};\n\nexport default addLife;\nexport { isLE };"]},"metadata":{},"sourceType":"module"}