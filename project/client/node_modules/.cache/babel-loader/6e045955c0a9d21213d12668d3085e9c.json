{"ast":null,"code":"import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport const SUCCESS_CODES = [200, 201, 202, 203, 204];\n\nconst getRequestData = (items, options) => {\n  let data;\n\n  if (options.sendWithFormData) {\n    logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);\n    }\n\n    const item = items[0];\n    logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);\n    data = item.file || item.url;\n  }\n\n  return data;\n};\n\nconst makeRequest = (items, url, options, onProgress, config) => {\n  let xhr;\n  const data = config !== null && config !== void 0 && config.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n\n  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {\n    requestOptions = merge({ ...pick(options, [\"method\", \"headers\", \"withCredentials\"]),\n      preSend: req => {\n        req.upload.onprogress = e => {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }, requestOptions);\n    const realPXhr = request(requestUrl, requestData, requestOptions); // $FlowFixMe -\n\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  }; //pXhr is a promise that resolves to the upload XHR\n\n\n  const pXhr = config !== null && config !== void 0 && config.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url,\n    count: items.length,\n    pXhr,\n    getXhr: () => xhr,\n    aborted: false\n  };\n};\n\nconst parseResponseJson = (response, headers, options) => {\n  let parsed = response;\n  const ct = headers === null || headers === void 0 ? void 0 : headers[\"content-type\"];\n\n  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch {//silent fail\n    }\n  }\n\n  return parsed;\n};\n\nconst processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {\n  var _options$formatServer, _options$formatServer2;\n\n  let state, response, status;\n  logger.debugLog(\"uploady.sender: received upload response \", xhr);\n  state = ~SUCCESS_CODES.indexOf(xhr.status) ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n  status = xhr.status;\n  const resHeaders = parseResponseHeaders(xhr);\n  response = {\n    data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),\n    headers: resHeaders\n  };\n  return {\n    status,\n    state,\n    response\n  };\n}).catch(error => {\n  let state, response;\n\n  if (sendRequest.aborted) {\n    state = FILE_STATES.ABORTED;\n    response = \"aborted\";\n  } else {\n    logger.debugLog(\"uploady.sender: upload failed: \", error);\n    state = FILE_STATES.ERROR;\n    response = error;\n  }\n\n  return {\n    error: true,\n    state,\n    response,\n    status: 0\n  };\n});\n\nconst abortRequest = sendRequest => {\n  let abortCalled = false;\n  const {\n    aborted,\n    getXhr\n  } = sendRequest;\n  const xhr = getXhr();\n\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n\n  return abortCalled;\n};\n\nconst getXhrSend = config => (items, url, options, onProgress) => {\n  if (!url) {\n    throw new MissingUrlError(XHR_SENDER_TYPE);\n  }\n\n  logger.debugLog(\"uploady.sender: sending file: \", {\n    items,\n    url,\n    options\n  });\n  const sendRequest = makeRequest(items, url, options, onProgress, config);\n  return {\n    request: processResponse(sendRequest, options),\n    abort: () => abortRequest(sendRequest),\n    senderType: XHR_SENDER_TYPE\n  };\n};\n\nexport default getXhrSend;","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/project-good/project/client/node_modules/@rpldy/sender/lib/esm/xhrSender/xhrSender.js"],"names":["logger","FILE_STATES","request","parseResponseHeaders","pick","merge","XHR_SENDER_TYPE","MissingUrlError","prepareFormData","SUCCESS_CODES","getRequestData","items","options","data","sendWithFormData","debugLog","length","Error","item","id","file","url","makeRequest","onProgress","config","xhr","issueRequest","requestUrl","requestData","requestOptions","preSend","req","upload","onprogress","e","lengthComputable","slice","realPXhr","pXhr","preRequestHandler","count","getXhr","aborted","parseResponseJson","response","headers","parsed","ct","forceJsonResponse","includes","JSON","parse","processResponse","sendRequest","then","_options$formatServer","_options$formatServer2","state","status","indexOf","FINISHED","ERROR","resHeaders","formatServerResponse","call","catch","error","ABORTED","abortRequest","abortCalled","readyState","abort","getXhrSend","senderType"],"mappings":"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","sourcesContent":["import { logger, FILE_STATES, request, parseResponseHeaders, pick, merge } from \"@rpldy/shared\";\nimport { XHR_SENDER_TYPE } from \"../consts\";\nimport MissingUrlError from \"../MissingUrlError\";\nimport prepareFormData from \"./prepareFormData\";\nexport const SUCCESS_CODES = [200, 201, 202, 203, 204];\n\nconst getRequestData = (items, options) => {\n  let data;\n\n  if (options.sendWithFormData) {\n    logger.debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);\n    data = prepareFormData(items, options);\n  } else {\n    if (items.length > 1) {\n      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);\n    }\n\n    const item = items[0];\n    logger.debugLog(`uploady.sender: sending item ${item.id} as request body`);\n    data = item.file || item.url;\n  }\n\n  return data;\n};\n\nconst makeRequest = (items, url, options, onProgress, config) => {\n  let xhr;\n  const data = config !== null && config !== void 0 && config.getRequestData ? config.getRequestData(items, options) : getRequestData(items, options);\n\n  const issueRequest = (requestUrl = url, requestData = data, requestOptions) => {\n    requestOptions = merge({ ...pick(options, [\"method\", \"headers\", \"withCredentials\"]),\n      preSend: req => {\n        req.upload.onprogress = e => {\n          if (e.lengthComputable && onProgress) {\n            onProgress(e, items.slice());\n          }\n        };\n      }\n    }, requestOptions);\n    const realPXhr = request(requestUrl, requestData, requestOptions); // $FlowFixMe -\n\n    xhr = realPXhr.xhr;\n    return realPXhr;\n  }; //pXhr is a promise that resolves to the upload XHR\n\n\n  const pXhr = config !== null && config !== void 0 && config.preRequestHandler ? config.preRequestHandler(issueRequest, items, url, options, onProgress, config) : issueRequest();\n  return {\n    url,\n    count: items.length,\n    pXhr,\n    getXhr: () => xhr,\n    aborted: false\n  };\n};\n\nconst parseResponseJson = (response, headers, options) => {\n  let parsed = response;\n  const ct = headers === null || headers === void 0 ? void 0 : headers[\"content-type\"];\n\n  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes(\"json\")) {\n    try {\n      parsed = JSON.parse(response);\n    } catch {//silent fail\n    }\n  }\n\n  return parsed;\n};\n\nconst processResponse = (sendRequest, options) => sendRequest.pXhr.then(xhr => {\n  var _options$formatServer, _options$formatServer2;\n\n  let state, response, status;\n  logger.debugLog(\"uploady.sender: received upload response \", xhr);\n  state = ~SUCCESS_CODES.indexOf(xhr.status) ? FILE_STATES.FINISHED : FILE_STATES.ERROR;\n  status = xhr.status;\n  const resHeaders = parseResponseHeaders(xhr);\n  response = {\n    data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),\n    headers: resHeaders\n  };\n  return {\n    status,\n    state,\n    response\n  };\n}).catch(error => {\n  let state, response;\n\n  if (sendRequest.aborted) {\n    state = FILE_STATES.ABORTED;\n    response = \"aborted\";\n  } else {\n    logger.debugLog(\"uploady.sender: upload failed: \", error);\n    state = FILE_STATES.ERROR;\n    response = error;\n  }\n\n  return {\n    error: true,\n    state,\n    response,\n    status: 0\n  };\n});\n\nconst abortRequest = sendRequest => {\n  let abortCalled = false;\n  const {\n    aborted,\n    getXhr\n  } = sendRequest;\n  const xhr = getXhr();\n\n  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {\n    logger.debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);\n    xhr.abort();\n    sendRequest.aborted = true;\n    abortCalled = true;\n  }\n\n  return abortCalled;\n};\n\nconst getXhrSend = config => (items, url, options, onProgress) => {\n  if (!url) {\n    throw new MissingUrlError(XHR_SENDER_TYPE);\n  }\n\n  logger.debugLog(\"uploady.sender: sending file: \", {\n    items,\n    url,\n    options\n  });\n  const sendRequest = makeRequest(items, url, options, onProgress, config);\n  return {\n    request: processResponse(sendRequest, options),\n    abort: () => abortRequest(sendRequest),\n    senderType: XHR_SENDER_TYPE\n  };\n};\n\nexport default getXhrSend;"]},"metadata":{},"sourceType":"module"}