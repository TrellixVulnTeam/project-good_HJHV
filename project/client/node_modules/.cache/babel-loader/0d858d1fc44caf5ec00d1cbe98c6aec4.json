{"ast":null,"code":"import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nconst EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nconst EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n      EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nlet counter = 0;\n\nconst createUploader = options => {\n  counter += 1;\n  const uploaderId = `uploader-${counter}`;\n  let enhancerTime = false;\n  const extensions = {};\n  logger.debugLog(`uploady.uploader: creating new instance (${uploaderId})`, {\n    options,\n    counter\n  });\n  let uploaderOptions = getMandatoryOptions(options);\n\n  const update = updateOptions => {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  const add = (files, addOptions) => {\n    const processOptions = merge({}, uploaderOptions, addOptions);\n\n    if (processOptions.clearPendingOnAdd) {\n      clearPending();\n    }\n\n    const batch = processor.addNewBatch(files, uploader.id, processOptions);\n    let resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(isCancelled => {\n        if (!isCancelled) {\n          logger.debugLog(`uploady.uploader [${uploader.id}]: new items added - auto upload =\n                        ${String(processOptions.autoUpload)}`, batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  const clearPending = () => {\n    processor.clearPendingBatches();\n  };\n  /**\n   * process batches that weren't auto-uploaded\n   */\n\n\n  const getOptions = () => {\n    return clone(uploaderOptions);\n  };\n\n  const registerExtension = (name, methods) => {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(`uploady.uploader: registering extension: ${name.toString()}`, methods);\n    extensions[name] = methods;\n  };\n\n  let {\n    trigger,\n    target: uploader\n  } = addLife({\n    id: uploaderId,\n    update,\n    add,\n    upload: uploadOptions => {\n      processor.processPendingBatches(uploadOptions);\n    },\n    abort: id => {\n      processor.abort(id);\n    },\n    abortBatch: id => {\n      processor.abortBatch(id);\n    },\n    getOptions,\n    clearPending,\n    registerExtension,\n    getExtension: name => {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  });\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n  const triggerWithUnwrap = (name, ...data) => {\n    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n    const lp = createLifePack(() => data.map(deepProxyUnwrap));\n    return trigger(name, lp);\n  };\n\n  const cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    const enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  const processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n};\n\nexport default createUploader;","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/project-good/project/client/node_modules/@rpldy/uploader/lib/esm/uploader.js"],"names":["addLife","createLifePack","BATCH_STATES","invariant","logger","triggerCancellable","devFreeze","merge","clone","getProcessor","UPLOADER_EVENTS","getMandatoryOptions","deepProxyUnwrap","EVENT_NAMES","Object","values","EXT_OUTSIDE_ENHANCER_TIME","EXT_ALREADY_EXISTS","counter","createUploader","options","uploaderId","enhancerTime","extensions","debugLog","uploaderOptions","update","updateOptions","uploader","add","files","addOptions","processOptions","clearPendingOnAdd","clearPending","batch","processor","addNewBatch","id","resultP","items","length","runCancellable","BATCH_ADD","then","isCancelled","String","autoUpload","process","state","CANCELLED","triggerWithUnwrap","BATCH_CANCEL","Promise","resolve","clearPendingBatches","getOptions","registerExtension","name","methods","toString","trigger","target","upload","uploadOptions","processPendingBatches","abort","abortBatch","getExtension","canAddEvents","canRemoveEvents","data","lp","map","cancellable","enhancer","enhanced"],"mappings":"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","sourcesContent":["import addLife, { createLifePack } from \"@rpldy/life-events\";\nimport { BATCH_STATES, invariant, logger, triggerCancellable, devFreeze, merge, clone } from \"@rpldy/shared\";\nimport getProcessor from \"./processor\";\nimport { UPLOADER_EVENTS } from \"./consts\";\nimport { getMandatoryOptions, deepProxyUnwrap } from \"./utils\";\nconst EVENT_NAMES = Object.values(UPLOADER_EVENTS);\nconst EXT_OUTSIDE_ENHANCER_TIME = \"Uploady - uploader extensions can only be registered by enhancers\",\n      EXT_ALREADY_EXISTS = \"Uploady - uploader extension by this name [%s] already exists\";\nlet counter = 0;\n\nconst createUploader = options => {\n  counter += 1;\n  const uploaderId = `uploader-${counter}`;\n  let enhancerTime = false;\n  const extensions = {};\n  logger.debugLog(`uploady.uploader: creating new instance (${uploaderId})`, {\n    options,\n    counter\n  });\n  let uploaderOptions = getMandatoryOptions(options);\n\n  const update = updateOptions => {\n    //TODO: updating concurrent and maxConcurrent means we need to update the processor - not supported yet!\n    uploaderOptions = merge({}, uploaderOptions, updateOptions); //need deep merge for destination\n\n    return uploader;\n  };\n\n  const add = (files, addOptions) => {\n    const processOptions = merge({}, uploaderOptions, addOptions);\n\n    if (processOptions.clearPendingOnAdd) {\n      clearPending();\n    }\n\n    const batch = processor.addNewBatch(files, uploader.id, processOptions);\n    let resultP;\n\n    if (batch.items.length) {\n      resultP = processor.runCancellable(UPLOADER_EVENTS.BATCH_ADD, batch, processOptions).then(isCancelled => {\n        if (!isCancelled) {\n          logger.debugLog(`uploady.uploader [${uploader.id}]: new items added - auto upload =\n                        ${String(processOptions.autoUpload)}`, batch.items);\n\n          if (processOptions.autoUpload) {\n            processor.process(batch);\n          }\n        } else {\n          batch.state = BATCH_STATES.CANCELLED;\n          triggerWithUnwrap(UPLOADER_EVENTS.BATCH_CANCEL, batch);\n        }\n      });\n    } else {\n      logger.debugLog(`uploady.uploader: no items to add. batch ${batch.id} is empty. check fileFilter if this isn't intended`);\n    }\n\n    return resultP || Promise.resolve();\n  };\n\n  const clearPending = () => {\n    processor.clearPendingBatches();\n  };\n  /**\n   * process batches that weren't auto-uploaded\n   */\n\n\n  const getOptions = () => {\n    return clone(uploaderOptions);\n  };\n\n  const registerExtension = (name, methods) => {\n    invariant(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);\n    invariant(!extensions[name], EXT_ALREADY_EXISTS, name);\n    logger.debugLog(`uploady.uploader: registering extension: ${name.toString()}`, methods);\n    extensions[name] = methods;\n  };\n\n  let {\n    trigger,\n    target: uploader\n  } = addLife({\n    id: uploaderId,\n    update,\n    add,\n    upload: uploadOptions => {\n      processor.processPendingBatches(uploadOptions);\n    },\n    abort: id => {\n      processor.abort(id);\n    },\n    abortBatch: id => {\n      processor.abortBatch(id);\n    },\n    getOptions,\n    clearPending,\n    registerExtension,\n    getExtension: name => {\n      return extensions[name];\n    }\n  }, EVENT_NAMES, {\n    canAddEvents: false,\n    canRemoveEvents: false\n  });\n  /**\n   * ensures that data being exposed to client-land isnt a proxy, only pojos\n   */\n\n  const triggerWithUnwrap = (name, ...data) => {\n    //delays unwrap to the very last time on trigger. Will only unwrap if there are listeners\n    const lp = createLifePack(() => data.map(deepProxyUnwrap));\n    return trigger(name, lp);\n  };\n\n  const cancellable = triggerCancellable(triggerWithUnwrap);\n\n  if (uploaderOptions.enhancer) {\n    enhancerTime = true;\n    const enhanced = uploaderOptions.enhancer(uploader, triggerWithUnwrap);\n    enhancerTime = false; //graceful handling for enhancer forgetting to return uploader\n\n    uploader = enhanced || uploader;\n  }\n\n  const processor = getProcessor(triggerWithUnwrap, cancellable, uploaderOptions, uploader.id);\n  return devFreeze(uploader);\n};\n\nexport default createUploader;"]},"metadata":{},"sourceType":"module"}