{"ast":null,"code":"import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport const FILE_STATE_TO_EVENT_MAP = {\n  [FILE_STATES.PENDING]: null,\n  [FILE_STATES.ADDED]: UPLOADER_EVENTS.ITEM_START,\n  [FILE_STATES.FINISHED]: UPLOADER_EVENTS.ITEM_FINISH,\n  [FILE_STATES.ERROR]: UPLOADER_EVENTS.ITEM_ERROR,\n  [FILE_STATES.CANCELLED]: UPLOADER_EVENTS.ITEM_CANCEL,\n  [FILE_STATES.ABORTED]: UPLOADER_EVENTS.ITEM_ABORT,\n  [FILE_STATES.UPLOADING]: UPLOADER_EVENTS.ITEM_PROGRESS\n};\n\nconst getIsFinalized = item => !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n\nconst processFinishedRequest = (queue, finishedData, next) => {\n  finishedData.forEach(itemData => {\n    const state = queue.getState();\n    const {\n      id,\n      info\n    } = itemData;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id,\n      info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(state => {\n        const item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      const item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    const index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(state => {\n        state.itemQueue.splice(index, 1);\n        const activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;","map":{"version":3,"sources":["C:/Users/USER/Documents/GitHub/project-good/project/client/node_modules/@rpldy/uploader/lib/esm/queue/processFinishedRequest.js"],"names":["FILE_STATES","logger","UPLOADER_EVENTS","ITEM_FINALIZE_STATES","cleanUpFinishedBatches","incrementBatchFinishedCounter","FILE_STATE_TO_EVENT_MAP","PENDING","ADDED","ITEM_START","FINISHED","ITEM_FINISH","ERROR","ITEM_ERROR","CANCELLED","ITEM_CANCEL","ABORTED","ITEM_ABORT","UPLOADING","ITEM_PROGRESS","getIsFinalized","item","indexOf","state","processFinishedRequest","queue","finishedData","next","forEach","itemData","getState","id","info","debugLog","items","updateState","uploadResponse","response","uploadStatus","status","aborts","completed","handleItemProgress","file","size","trigger","batchId","ITEM_FINALIZE","index","itemQueue","splice","activeIndex","activeIds"],"mappings":"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","sourcesContent":["import { FILE_STATES, logger } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from \"../consts\";\nimport { cleanUpFinishedBatches, incrementBatchFinishedCounter } from \"./batchHelpers\";\nexport const FILE_STATE_TO_EVENT_MAP = {\n  [FILE_STATES.PENDING]: null,\n  [FILE_STATES.ADDED]: UPLOADER_EVENTS.ITEM_START,\n  [FILE_STATES.FINISHED]: UPLOADER_EVENTS.ITEM_FINISH,\n  [FILE_STATES.ERROR]: UPLOADER_EVENTS.ITEM_ERROR,\n  [FILE_STATES.CANCELLED]: UPLOADER_EVENTS.ITEM_CANCEL,\n  [FILE_STATES.ABORTED]: UPLOADER_EVENTS.ITEM_ABORT,\n  [FILE_STATES.UPLOADING]: UPLOADER_EVENTS.ITEM_PROGRESS\n};\n\nconst getIsFinalized = item => !!~ITEM_FINALIZE_STATES.indexOf(item.state);\n\nconst processFinishedRequest = (queue, finishedData, next) => {\n  finishedData.forEach(itemData => {\n    const state = queue.getState();\n    const {\n      id,\n      info\n    } = itemData;\n    logger.debugLog(\"uploader.processor.queue: request finished for item - \", {\n      id,\n      info\n    });\n\n    if (state.items[id]) {\n      queue.updateState(state => {\n        const item = state.items[id];\n        item.state = info.state;\n        item.uploadResponse = info.response;\n        item.uploadStatus = info.status;\n\n        if (getIsFinalized(item)) {\n          delete state.aborts[id];\n        }\n      }); //get most up-to-date item data\n\n      const item = queue.getState().items[id];\n\n      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {\n        //ensure we trigger progress event with completed = 100 for all items\n        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);\n      }\n\n      if (FILE_STATE_TO_EVENT_MAP[item.state]) {\n        //trigger UPLOADER EVENT for item based on its state\n        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);\n      }\n\n      if (getIsFinalized(item)) {\n        incrementBatchFinishedCounter(queue, item.batchId); //trigger FINALIZE event\n\n        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);\n      }\n    }\n\n    const index = state.itemQueue.indexOf(id);\n\n    if (~index) {\n      queue.updateState(state => {\n        state.itemQueue.splice(index, 1);\n        const activeIndex = state.activeIds.indexOf(id);\n\n        if (~activeIndex) {\n          state.activeIds.splice(activeIndex, 1);\n        }\n      });\n    }\n  }); //ensure finished batches are remove from state\n\n  cleanUpFinishedBatches(queue);\n  return next(queue);\n};\n\nexport default processFinishedRequest;"]},"metadata":{},"sourceType":"module"}