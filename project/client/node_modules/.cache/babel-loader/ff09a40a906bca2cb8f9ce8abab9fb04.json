{"ast":null,"code":"import isPlainObject from \"./isPlainObject\";\nexport const isMergeObj = obj => isPlainObject(obj) || Array.isArray(obj);\n\nconst getKeys = (obj, options) => {\n  const keys = Object.keys(obj);\n  return options.withSymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;\n};\n\nconst getMerge = (options = {}) => {\n  const merge = (target, ...sources) => {\n    if (target && sources.length) {\n      sources.forEach(source => {\n        if (source) {\n          getKeys(source, options).forEach(key => {\n            const prop = source[key];\n\n            if (!options.predicate || options.predicate(key, prop)) {\n              if (typeof prop !== \"undefined\" || options.undefinedOverwrites) {\n                //object/array - go deeper\n                if (isMergeObj(prop)) {\n                  if (typeof target[key] === \"undefined\" || !isPlainObject(target[key])) {\n                    //recreate target prop if doesnt exist or not an object\n                    target[key] = Array.isArray(prop) ? [] : {};\n                  }\n\n                  merge(target[key], prop);\n                } else {\n                  target[key] = prop;\n                }\n              }\n            }\n          });\n        }\n      });\n    }\n\n    return target;\n  };\n\n  return merge;\n};\n/**\r\n * Does deep merge of simple objects and arrays (only)\r\n *\r\n * The first parameter is the target\r\n * Will only merge objects passed as arguments to this method\r\n * Any property in a later object will simply override the one in a previous one\r\n * Undefined properties from sources will be ignored\r\n *\r\n * No recursion protection\r\n */\n\n\nexport default getMerge();\nexport { getMerge };","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/shared/lib/esm/utils/merge.js"],"names":["isPlainObject","isMergeObj","obj","Array","isArray","getKeys","options","keys","Object","withSymbols","concat","getOwnPropertySymbols","getMerge","merge","target","sources","length","forEach","source","key","prop","predicate","undefinedOverwrites"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,OAAO,MAAMC,UAAU,GAAGC,GAAG,IAAIF,aAAa,CAACE,GAAD,CAAb,IAAsBC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAhD;;AAEP,MAAMG,OAAO,GAAG,CAACH,GAAD,EAAMI,OAAN,KAAkB;AAChC,QAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYL,GAAZ,CAAb;AACA,SAAOI,OAAO,CAACG,WAAR,GAAsBF,IAAI,CAACG,MAAL,CAAYF,MAAM,CAACG,qBAAP,CAA6BT,GAA7B,CAAZ,CAAtB,GAAuEK,IAA9E;AACD,CAHD;;AAKA,MAAMK,QAAQ,GAAG,CAACN,OAAO,GAAG,EAAX,KAAkB;AACjC,QAAMO,KAAK,GAAG,CAACC,MAAD,EAAS,GAAGC,OAAZ,KAAwB;AACpC,QAAID,MAAM,IAAIC,OAAO,CAACC,MAAtB,EAA8B;AAC5BD,MAAAA,OAAO,CAACE,OAAR,CAAgBC,MAAM,IAAI;AACxB,YAAIA,MAAJ,EAAY;AACVb,UAAAA,OAAO,CAACa,MAAD,EAASZ,OAAT,CAAP,CAAyBW,OAAzB,CAAiCE,GAAG,IAAI;AACtC,kBAAMC,IAAI,GAAGF,MAAM,CAACC,GAAD,CAAnB;;AAEA,gBAAI,CAACb,OAAO,CAACe,SAAT,IAAsBf,OAAO,CAACe,SAAR,CAAkBF,GAAlB,EAAuBC,IAAvB,CAA1B,EAAwD;AACtD,kBAAI,OAAOA,IAAP,KAAgB,WAAhB,IAA+Bd,OAAO,CAACgB,mBAA3C,EAAgE;AAC9D;AACA,oBAAIrB,UAAU,CAACmB,IAAD,CAAd,EAAsB;AACpB,sBAAI,OAAON,MAAM,CAACK,GAAD,CAAb,KAAuB,WAAvB,IAAsC,CAACnB,aAAa,CAACc,MAAM,CAACK,GAAD,CAAP,CAAxD,EAAuE;AACrE;AACAL,oBAAAA,MAAM,CAACK,GAAD,CAAN,GAAchB,KAAK,CAACC,OAAN,CAAcgB,IAAd,IAAsB,EAAtB,GAA2B,EAAzC;AACD;;AAEDP,kBAAAA,KAAK,CAACC,MAAM,CAACK,GAAD,CAAP,EAAcC,IAAd,CAAL;AACD,iBAPD,MAOO;AACLN,kBAAAA,MAAM,CAACK,GAAD,CAAN,GAAcC,IAAd;AACD;AACF;AACF;AACF,WAlBD;AAmBD;AACF,OAtBD;AAuBD;;AAED,WAAON,MAAP;AACD,GA5BD;;AA8BA,SAAOD,KAAP;AACD,CAhCD;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAeD,QAAQ,EAAvB;AACA,SAASA,QAAT","sourcesContent":["import isPlainObject from \"./isPlainObject\";\r\nexport const isMergeObj = obj => isPlainObject(obj) || Array.isArray(obj);\r\n\r\nconst getKeys = (obj, options) => {\r\n  const keys = Object.keys(obj);\r\n  return options.withSymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;\r\n};\r\n\r\nconst getMerge = (options = {}) => {\r\n  const merge = (target, ...sources) => {\r\n    if (target && sources.length) {\r\n      sources.forEach(source => {\r\n        if (source) {\r\n          getKeys(source, options).forEach(key => {\r\n            const prop = source[key];\r\n\r\n            if (!options.predicate || options.predicate(key, prop)) {\r\n              if (typeof prop !== \"undefined\" || options.undefinedOverwrites) {\r\n                //object/array - go deeper\r\n                if (isMergeObj(prop)) {\r\n                  if (typeof target[key] === \"undefined\" || !isPlainObject(target[key])) {\r\n                    //recreate target prop if doesnt exist or not an object\r\n                    target[key] = Array.isArray(prop) ? [] : {};\r\n                  }\r\n\r\n                  merge(target[key], prop);\r\n                } else {\r\n                  target[key] = prop;\r\n                }\r\n              }\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  return merge;\r\n};\r\n/**\r\n * Does deep merge of simple objects and arrays (only)\r\n *\r\n * The first parameter is the target\r\n * Will only merge objects passed as arguments to this method\r\n * Any property in a later object will simply override the one in a previous one\r\n * Undefined properties from sources will be ignored\r\n *\r\n * No recursion protection\r\n */\r\n\r\n\r\nexport default getMerge();\r\nexport { getMerge };"]},"metadata":{},"sourceType":"module"}