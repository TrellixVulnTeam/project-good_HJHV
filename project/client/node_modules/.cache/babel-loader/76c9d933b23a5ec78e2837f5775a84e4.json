{"ast":null,"code":"import { clone, getMerge, isProduction } from \"@rpldy/shared\";\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\nimport { isProxiable, isProxy } from \"./utils\";\nconst mergeWithSymbols = getMerge({\n  withSymbols: true,\n  predicate: key => key !== PROXY_SYM && key !== STATE_SYM\n});\n\nconst getIsUpdateable = proxy => isProduction() ? true : proxy[STATE_SYM].isUpdateable;\n\nconst setIsUpdateable = (proxy, value) => {\n  if (!isProduction()) {\n    proxy[STATE_SYM].isUpdateable = value;\n  }\n};\n\nconst deepProxy = (obj, traps) => {\n  let proxy;\n\n  if (isProxiable(obj)) {\n    if (!isProxy(obj)) {\n      obj[PROXY_SYM] = true;\n      proxy = new Proxy(obj, traps);\n    }\n\n    Object.keys(obj).forEach(key => {\n      obj[key] = deepProxy(obj[key], traps);\n    });\n  }\n\n  return proxy || obj;\n};\n\nconst unwrapProxy = proxy => isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\n/**\r\n * deep proxies an object so it is only updateable through an update callback.\r\n * outside an updater, it is impossible to make changes\r\n *\r\n * This a very (very) basic and naive replacement for Immer\r\n *\r\n * It only proxies simple objects (not maps or sets) and arrays\r\n * It doesnt create new references and doesnt copy over anything\r\n *\r\n * Original object is changed!\r\n *\r\n * DOESNT support updating state (wrapped seperately) that is set as a child of another state\r\n * @param obj\r\n * @returns {{state, update, unwrap}}\r\n */\n\n\nexport default (obj => {\n  const traps = {\n    set: (obj, key, value) => {\n      if (getIsUpdateable(proxy)) {\n        obj[key] = deepProxy(value, traps);\n      }\n\n      return true;\n    },\n    get: (obj, key) => {\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\n    },\n    defineProperty: () => {\n      throw new Error(\"Simple State doesnt support defining property\");\n    },\n    setPrototypeOf: () => {\n      throw new Error(\"Simple State doesnt support setting prototype\");\n    },\n    deleteProperty: (obj, key) => {\n      if (getIsUpdateable(proxy)) {\n        delete obj[key];\n      }\n\n      return true;\n    }\n  };\n\n  if (!isProduction() && !isProxy(obj)) {\n    Object.defineProperty(obj, STATE_SYM, {\n      value: {\n        isUpdateable: false\n      },\n      configurable: true\n    });\n  }\n\n  const proxy = !isProduction() ? deepProxy(obj, traps) : obj;\n  return {\n    state: proxy,\n    update: fn => {\n      if (!isProduction() && getIsUpdateable(proxy)) {\n        throw new Error(\"Can't call update on State already being updated!\");\n      }\n\n      try {\n        setIsUpdateable(proxy, true);\n        fn(proxy);\n      } finally {\n        setIsUpdateable(proxy, false);\n      }\n\n      return proxy;\n    },\n    unwrap: entry => entry ? //simply clone the provided object (if its a proxy)\n    unwrapProxy(entry) : //unwrap entire proxy state\n    isProxy(proxy) ? unwrapProxy(proxy) : proxy\n  };\n});\nexport { isProxy, unwrapProxy as unwrap };","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/simple-state/lib/esm/createState.js"],"names":["clone","getMerge","isProduction","PROXY_SYM","STATE_SYM","isProxiable","isProxy","mergeWithSymbols","withSymbols","predicate","key","getIsUpdateable","proxy","isUpdateable","setIsUpdateable","value","deepProxy","obj","traps","Proxy","Object","keys","forEach","unwrapProxy","set","get","defineProperty","Error","setPrototypeOf","deleteProperty","configurable","state","update","fn","unwrap","entry"],"mappings":"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","sourcesContent":["import { clone, getMerge, isProduction } from \"@rpldy/shared\";\r\nimport { PROXY_SYM, STATE_SYM } from \"./consts\";\r\nimport { isProxiable, isProxy } from \"./utils\";\r\nconst mergeWithSymbols = getMerge({\r\n  withSymbols: true,\r\n  predicate: key => key !== PROXY_SYM && key !== STATE_SYM\r\n});\r\n\r\nconst getIsUpdateable = proxy => isProduction() ? true : proxy[STATE_SYM].isUpdateable;\r\n\r\nconst setIsUpdateable = (proxy, value) => {\r\n  if (!isProduction()) {\r\n    proxy[STATE_SYM].isUpdateable = value;\r\n  }\r\n};\r\n\r\nconst deepProxy = (obj, traps) => {\r\n  let proxy;\r\n\r\n  if (isProxiable(obj)) {\r\n    if (!isProxy(obj)) {\r\n      obj[PROXY_SYM] = true;\r\n      proxy = new Proxy(obj, traps);\r\n    }\r\n\r\n    Object.keys(obj).forEach(key => {\r\n      obj[key] = deepProxy(obj[key], traps);\r\n    });\r\n  }\r\n\r\n  return proxy || obj;\r\n};\r\n\r\nconst unwrapProxy = proxy => isProxy(proxy) ? clone(proxy, mergeWithSymbols) : proxy;\r\n/**\r\n * deep proxies an object so it is only updateable through an update callback.\r\n * outside an updater, it is impossible to make changes\r\n *\r\n * This a very (very) basic and naive replacement for Immer\r\n *\r\n * It only proxies simple objects (not maps or sets) and arrays\r\n * It doesnt create new references and doesnt copy over anything\r\n *\r\n * Original object is changed!\r\n *\r\n * DOESNT support updating state (wrapped seperately) that is set as a child of another state\r\n * @param obj\r\n * @returns {{state, update, unwrap}}\r\n */\r\n\r\n\r\nexport default (obj => {\r\n  const traps = {\r\n    set: (obj, key, value) => {\r\n      if (getIsUpdateable(proxy)) {\r\n        obj[key] = deepProxy(value, traps);\r\n      }\r\n\r\n      return true;\r\n    },\r\n    get: (obj, key) => {\r\n      return key === PROXY_SYM ? unwrapProxy(obj) : obj[key];\r\n    },\r\n    defineProperty: () => {\r\n      throw new Error(\"Simple State doesnt support defining property\");\r\n    },\r\n    setPrototypeOf: () => {\r\n      throw new Error(\"Simple State doesnt support setting prototype\");\r\n    },\r\n    deleteProperty: (obj, key) => {\r\n      if (getIsUpdateable(proxy)) {\r\n        delete obj[key];\r\n      }\r\n\r\n      return true;\r\n    }\r\n  };\r\n\r\n  if (!isProduction() && !isProxy(obj)) {\r\n    Object.defineProperty(obj, STATE_SYM, {\r\n      value: {\r\n        isUpdateable: false\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  const proxy = !isProduction() ? deepProxy(obj, traps) : obj;\r\n  return {\r\n    state: proxy,\r\n    update: fn => {\r\n      if (!isProduction() && getIsUpdateable(proxy)) {\r\n        throw new Error(\"Can't call update on State already being updated!\");\r\n      }\r\n\r\n      try {\r\n        setIsUpdateable(proxy, true);\r\n        fn(proxy);\r\n      } finally {\r\n        setIsUpdateable(proxy, false);\r\n      }\r\n\r\n      return proxy;\r\n    },\r\n    unwrap: entry => entry ? //simply clone the provided object (if its a proxy)\r\n    unwrapProxy(entry) : //unwrap entire proxy state\r\n    isProxy(proxy) ? unwrapProxy(proxy) : proxy\r\n  };\r\n});\r\nexport { isProxy, unwrapProxy as unwrap };"]},"metadata":{},"sourceType":"module"}