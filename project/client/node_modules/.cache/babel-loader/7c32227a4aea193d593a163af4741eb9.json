{"ast":null,"code":"import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\nimport { UPLOADER_EVENTS } from \"../consts\";\nimport processFinishedRequest from \"./processFinishedRequest\";\nconst mergeWithUndefined = getMerge({\n  undefinedOverwrites: true\n});\n\nconst triggerPreSendUpdate = (queue, items, options) => {\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\n    items,\n    options\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\n  .then(updated => {\n    if (updated) {\n      logger.debugLog(`uploader.queue: REQUEST_PRE_SEND event returned updated items/options`, updated);\n\n      if (updated.items) {\n        //can't change items count at this point.\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\n          throw new Error(`REQUEST_PRE_SEND event handlers must return same items with same ids`);\n        }\n\n        items = updated.items;\n      }\n\n      if (updated.options) {\n        options = mergeWithUndefined({}, options, updated.options);\n      }\n    }\n\n    return {\n      items,\n      options,\n      cancelled: updated === false\n    };\n  });\n};\n\nconst prepareAllowedItems = (queue, items) => {\n  const allowedIds = items.map(item => item.id);\n  queue.updateState(state => {\n    state.activeIds = state.activeIds.concat(allowedIds);\n  });\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(prepared => {\n    if (!prepared.cancelled) {\n      //update potentially changed data back into queue state\n      queue.updateState(state => {\n        prepared.items.forEach(i => {\n          state.items[i.id] = i;\n        });\n        state.batches[items[0].batchId].batchOptions = prepared.options;\n      }); //use objects from internal state(proxies) - not objects from userland\n\n      const updatedState = queue.getState();\n      prepared.items = prepared.items.map(item => updatedState.items[item.id]);\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\n    }\n\n    return prepared;\n  });\n};\n\nconst updateUploadingState = (queue, items, sendResult) => {\n  queue.updateState(state => {\n    items.forEach(bi => {\n      const item = state.items[bi.id];\n      item.state = FILE_STATES.UPLOADING;\n      state.aborts[bi.id] = sendResult.abort;\n    });\n  });\n};\n\nconst sendAllowedItems = (queue, itemsSendData, next) => {\n  const {\n    items,\n    options\n  } = itemsSendData;\n  const batch = queue.getState().batches[items[0].batchId].batch;\n  let sendResult;\n\n  try {\n    sendResult = queue.sender.send(items, batch, options);\n  } catch (ex) {\n    logger.debugLog(`uploader.queue: sender failed with unexpected error`, ex); //provide error result so file(s) are marked as failed\n\n    sendResult = {\n      request: Promise.resolve({\n        status: 0,\n        state: FILE_STATES.ERROR,\n        response: ex.message\n      }),\n      abort: () => false,\n      senderType: \"exception-handler\"\n    };\n  }\n\n  const {\n    request\n  } = sendResult;\n  updateUploadingState(queue, items, sendResult);\n  return request //wait for server request to return\n  .then(requestInfo => {\n    const finishedData = items.map(item => ({\n      id: item.id,\n      info: requestInfo\n    }));\n    processFinishedRequest(queue, finishedData, next);\n  });\n};\n\nconst reportCancelledItems = (queue, items, cancelledResults, next) => {\n  const cancelledItemsIds = cancelledResults.map((isCancelled, index) => isCancelled ? items[index].id : null).filter(Boolean);\n\n  if (cancelledItemsIds.length) {\n    const finishedData = cancelledItemsIds.map(id => ({\n      id,\n      info: {\n        status: 0,\n        state: FILE_STATES.CANCELLED,\n        response: \"cancel\"\n      }\n    }));\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\n  }\n\n  return !!cancelledItemsIds.length;\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\n\n\nconst getAllowedItem = (id, queue) => queue.getState().items[id]; //send group of items to be uploaded\n\n\nconst processBatchItems = (queue, ids, next) => {\n  const state = queue.getState(); //ids will have more than one when grouping is allowed\n\n  let items = Object.values(state.items);\n  items = items.filter(item => !!~ids.indexOf(item.id)); //allow user code cancel items from start event handler(s)\n\n  return Promise.all(items.map(i => queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i))).then(cancelledResults => {\n    let allowedItems = cancelledResults.map((isCancelled, index) => isCancelled ? null : getAllowedItem(items[index].id, queue)).filter(Boolean);\n    return {\n      allowedItems,\n      cancelledResults\n    };\n  }).then(({\n    allowedItems,\n    cancelledResults\n  }) => {\n    const afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\n    return afterPreparePromise.then(itemsSendData => {\n      let nextP;\n\n      if (itemsSendData) {\n        if (itemsSendData.cancelled) {\n          cancelledResults = ids.map(() => true);\n        } else {\n          //we dont need to wait for the response here\n          sendAllowedItems(queue, itemsSendData, next);\n        }\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\n\n\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\n      }\n\n      return nextP;\n    });\n  });\n};\n\nexport default processBatchItems;","map":{"version":3,"sources":["D:/project-good/project/client/node_modules/@rpldy/uploader/lib/esm/queue/processBatchItems.js"],"names":["triggerUpdater","isSamePropInArrays","FILE_STATES","logger","getMerge","UPLOADER_EVENTS","processFinishedRequest","mergeWithUndefined","undefinedOverwrites","triggerPreSendUpdate","queue","items","options","trigger","REQUEST_PRE_SEND","then","updated","debugLog","length","Error","cancelled","prepareAllowedItems","allowedIds","map","item","id","updateState","state","activeIds","concat","getState","batches","batchId","batchOptions","prepared","forEach","i","updatedState","updateUploadingState","sendResult","bi","UPLOADING","aborts","abort","sendAllowedItems","itemsSendData","next","batch","sender","send","ex","request","Promise","resolve","status","ERROR","response","message","senderType","requestInfo","finishedData","info","reportCancelledItems","cancelledResults","cancelledItemsIds","isCancelled","index","filter","Boolean","CANCELLED","getAllowedItem","processBatchItems","ids","Object","values","indexOf","all","runCancellable","ITEM_START","allowedItems","afterPreparePromise","nextP"],"mappings":"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","sourcesContent":["import { triggerUpdater, isSamePropInArrays, FILE_STATES, logger, getMerge } from \"@rpldy/shared\";\r\nimport { UPLOADER_EVENTS } from \"../consts\";\r\nimport processFinishedRequest from \"./processFinishedRequest\";\r\nconst mergeWithUndefined = getMerge({\r\n  undefinedOverwrites: true\r\n});\r\n\r\nconst triggerPreSendUpdate = (queue, items, options) => {\r\n  return triggerUpdater(queue.trigger, UPLOADER_EVENTS.REQUEST_PRE_SEND, {\r\n    items,\r\n    options\r\n  }) // $FlowFixMe - https://github.com/facebook/flow/issues/8215\r\n  .then(updated => {\r\n    if (updated) {\r\n      logger.debugLog(`uploader.queue: REQUEST_PRE_SEND event returned updated items/options`, updated);\r\n\r\n      if (updated.items) {\r\n        //can't change items count at this point.\r\n        if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, [\"id\", \"batchId\", \"recycled\"])) {\r\n          throw new Error(`REQUEST_PRE_SEND event handlers must return same items with same ids`);\r\n        }\r\n\r\n        items = updated.items;\r\n      }\r\n\r\n      if (updated.options) {\r\n        options = mergeWithUndefined({}, options, updated.options);\r\n      }\r\n    }\r\n\r\n    return {\r\n      items,\r\n      options,\r\n      cancelled: updated === false\r\n    };\r\n  });\r\n};\r\n\r\nconst prepareAllowedItems = (queue, items) => {\r\n  const allowedIds = items.map(item => item.id);\r\n  queue.updateState(state => {\r\n    state.activeIds = state.activeIds.concat(allowedIds);\r\n  });\r\n  return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions).then(prepared => {\r\n    if (!prepared.cancelled) {\r\n      //update potentially changed data back into queue state\r\n      queue.updateState(state => {\r\n        prepared.items.forEach(i => {\r\n          state.items[i.id] = i;\r\n        });\r\n        state.batches[items[0].batchId].batchOptions = prepared.options;\r\n      }); //use objects from internal state(proxies) - not objects from userland\r\n\r\n      const updatedState = queue.getState();\r\n      prepared.items = prepared.items.map(item => updatedState.items[item.id]);\r\n      prepared.options = updatedState.batches[items[0].batchId].batchOptions;\r\n    }\r\n\r\n    return prepared;\r\n  });\r\n};\r\n\r\nconst updateUploadingState = (queue, items, sendResult) => {\r\n  queue.updateState(state => {\r\n    items.forEach(bi => {\r\n      const item = state.items[bi.id];\r\n      item.state = FILE_STATES.UPLOADING;\r\n      state.aborts[bi.id] = sendResult.abort;\r\n    });\r\n  });\r\n};\r\n\r\nconst sendAllowedItems = (queue, itemsSendData, next) => {\r\n  const {\r\n    items,\r\n    options\r\n  } = itemsSendData;\r\n  const batch = queue.getState().batches[items[0].batchId].batch;\r\n  let sendResult;\r\n\r\n  try {\r\n    sendResult = queue.sender.send(items, batch, options);\r\n  } catch (ex) {\r\n    logger.debugLog(`uploader.queue: sender failed with unexpected error`, ex); //provide error result so file(s) are marked as failed\r\n\r\n    sendResult = {\r\n      request: Promise.resolve({\r\n        status: 0,\r\n        state: FILE_STATES.ERROR,\r\n        response: ex.message\r\n      }),\r\n      abort: () => false,\r\n      senderType: \"exception-handler\"\r\n    };\r\n  }\r\n\r\n  const {\r\n    request\r\n  } = sendResult;\r\n  updateUploadingState(queue, items, sendResult);\r\n  return request //wait for server request to return\r\n  .then(requestInfo => {\r\n    const finishedData = items.map(item => ({\r\n      id: item.id,\r\n      info: requestInfo\r\n    }));\r\n    processFinishedRequest(queue, finishedData, next);\r\n  });\r\n};\r\n\r\nconst reportCancelledItems = (queue, items, cancelledResults, next) => {\r\n  const cancelledItemsIds = cancelledResults.map((isCancelled, index) => isCancelled ? items[index].id : null).filter(Boolean);\r\n\r\n  if (cancelledItemsIds.length) {\r\n    const finishedData = cancelledItemsIds.map(id => ({\r\n      id,\r\n      info: {\r\n        status: 0,\r\n        state: FILE_STATES.CANCELLED,\r\n        response: \"cancel\"\r\n      }\r\n    }));\r\n    processFinishedRequest(queue, finishedData, next); //report about cancelled items\r\n  }\r\n\r\n  return !!cancelledItemsIds.length;\r\n}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...\r\n\r\n\r\nconst getAllowedItem = (id, queue) => queue.getState().items[id]; //send group of items to be uploaded\r\n\r\n\r\nconst processBatchItems = (queue, ids, next) => {\r\n  const state = queue.getState(); //ids will have more than one when grouping is allowed\r\n\r\n  let items = Object.values(state.items);\r\n  items = items.filter(item => !!~ids.indexOf(item.id)); //allow user code cancel items from start event handler(s)\r\n\r\n  return Promise.all(items.map(i => queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i))).then(cancelledResults => {\r\n    let allowedItems = cancelledResults.map((isCancelled, index) => isCancelled ? null : getAllowedItem(items[index].id, queue)).filter(Boolean);\r\n    return {\r\n      allowedItems,\r\n      cancelledResults\r\n    };\r\n  }).then(({\r\n    allowedItems,\r\n    cancelledResults\r\n  }) => {\r\n    const afterPreparePromise = allowedItems.length ? prepareAllowedItems(queue, allowedItems).then() : Promise.resolve();\r\n    return afterPreparePromise.then(itemsSendData => {\r\n      let nextP;\r\n\r\n      if (itemsSendData) {\r\n        if (itemsSendData.cancelled) {\r\n          cancelledResults = ids.map(() => true);\r\n        } else {\r\n          //we dont need to wait for the response here\r\n          sendAllowedItems(queue, itemsSendData, next);\r\n        }\r\n      } //if no cancelled we can go to process more items immediately (and not wait for upload responses)\r\n\r\n\r\n      if (!reportCancelledItems(queue, items, cancelledResults, next)) {\r\n        nextP = next(queue); //when concurrent is allowed, we can go ahead and process more\r\n      }\r\n\r\n      return nextP;\r\n    });\r\n  });\r\n};\r\n\r\nexport default processBatchItems;"]},"metadata":{},"sourceType":"module"}